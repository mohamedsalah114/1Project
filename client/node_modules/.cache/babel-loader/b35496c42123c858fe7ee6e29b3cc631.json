{"ast":null,"code":"import { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim\";\n\nfunction createReaction(adm) {\n  adm.reaction = new Reaction(\"observer\".concat(adm.name), function () {\n    var _a;\n\n    adm.stateVersion = Symbol(); // onStoreChange won't be available until the component \"mounts\".\n    // If state changes in between initial render and mount,\n    // `useSyncExternalStore` should handle that by checking the state version and issuing update.\n\n    (_a = adm.onStoreChange) === null || _a === void 0 ? void 0 : _a.call(adm);\n  });\n}\n\nexport function useObserver(render, baseComponentName) {\n  if (baseComponentName === void 0) {\n    baseComponentName = \"observed\";\n  }\n\n  if (isUsingStaticRendering()) {\n    return render();\n  }\n\n  var admRef = React.useRef(null);\n\n  if (!admRef.current) {\n    // First render\n    var adm_1 = {\n      reaction: null,\n      onStoreChange: null,\n      stateVersion: Symbol(),\n      name: baseComponentName,\n      subscribe: function (onStoreChange) {\n        // Do NOT access admRef here!\n        observerFinalizationRegistry.unregister(adm_1);\n        adm_1.onStoreChange = onStoreChange;\n\n        if (!adm_1.reaction) {\n          // We've lost our reaction and therefore all subscriptions, occurs when:\n          // 1. Timer based finalization registry disposed reaction before component mounted.\n          // 2. React \"re-mounts\" same component without calling render in between (typically <StrictMode>).\n          // We have to recreate reaction and schedule re-render to recreate subscriptions,\n          // even if state did not change.\n          createReaction(adm_1); // `onStoreChange` won't force update if subsequent `getSnapshot` returns same value.\n          // So we make sure that is not the case\n\n          adm_1.stateVersion = Symbol();\n        }\n\n        return function () {\n          var _a; // Do NOT access admRef here!\n\n\n          adm_1.onStoreChange = null;\n          (_a = adm_1.reaction) === null || _a === void 0 ? void 0 : _a.dispose();\n          adm_1.reaction = null;\n        };\n      },\n      getSnapshot: function () {\n        // Do NOT access admRef here!\n        return adm_1.stateVersion;\n      }\n    };\n    admRef.current = adm_1;\n  }\n\n  var adm = admRef.current;\n\n  if (!adm.reaction) {\n    // First render or reaction was disposed by registry before subscribe\n    createReaction(adm); // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n\n    observerFinalizationRegistry.register(admRef, adm, adm);\n  }\n\n  React.useDebugValue(adm.reaction, printDebugValue);\n  useSyncExternalStore( // Both of these must be stable, otherwise it would keep resubscribing every render.\n  adm.subscribe, adm.getSnapshot, adm.getSnapshot); // render the original component, but have the\n  // reaction track the observables, so that rendering\n  // can be invalidated (see above) once a dependency changes\n\n  var renderResult;\n  var exception;\n  adm.reaction.track(function () {\n    try {\n      renderResult = render();\n    } catch (e) {\n      exception = e;\n    }\n  });\n\n  if (exception) {\n    throw exception; // re-throw any exceptions caught during rendering\n  }\n\n  return renderResult;\n}","map":{"version":3,"mappings":"AAAA,SAASA,QAAT,QAAyB,MAAzB;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,SAASC,eAAT,QAAgC,yBAAhC;AACA,SAASC,sBAAT,QAAuC,mBAAvC;AACA,SAASC,4BAAT,QAA6C,sCAA7C;AACA,SAASC,oBAAT,QAAqC,8BAArC;;AAmBA,SAASC,cAAT,CAAwBC,GAAxB,EAAmD;EAC/CA,GAAG,CAACC,QAAJ,GAAe,IAAIR,QAAJ,CAAa,kBAAWO,GAAG,CAACE,IAAf,CAAb,EAAoC;;;IAC/CF,GAAG,CAACG,YAAJ,GAAmBC,MAAM,EAAzB,CAD+C,CAE/C;IACA;IACA;;IACA,SAAG,CAACC,aAAJ,MAAiB,IAAjB,IAAiBC,aAAjB,GAAiB,MAAjB,GAAiBA,YAAjB;EACH,CANc,CAAf;AAOH;;AAED,OAAM,SAAUC,WAAV,CAAyBC,MAAzB,EAA0CC,iBAA1C,EAAgF;EAAtC;IAAAA;EAAsC;;EAClF,IAAIb,sBAAsB,EAA1B,EAA8B;IAC1B,OAAOY,MAAM,EAAb;EACH;;EAED,IAAME,MAAM,GAAGhB,KAAK,CAACiB,MAAN,CAA4C,IAA5C,CAAf;;EAEA,IAAI,CAACD,MAAM,CAACE,OAAZ,EAAqB;IACjB;IACA,IAAMC,KAAG,GAA2B;MAChCZ,QAAQ,EAAE,IADsB;MAEhCI,aAAa,EAAE,IAFiB;MAGhCF,YAAY,EAAEC,MAAM,EAHY;MAIhCF,IAAI,EAAEO,iBAJ0B;MAKhCK,SAAS,YAACT,aAAD,EAA0B;QAC/B;QACAR,4BAA4B,CAACkB,UAA7B,CAAwCF,KAAxC;QACAA,KAAG,CAACR,aAAJ,GAAoBA,aAApB;;QACA,IAAI,CAACQ,KAAG,CAACZ,QAAT,EAAmB;UACf;UACA;UACA;UACA;UACA;UACAF,cAAc,CAACc,KAAD,CAAd,CANe,CAOf;UACA;;UACAA,KAAG,CAACV,YAAJ,GAAmBC,MAAM,EAAzB;QACH;;QAED,OAAO;iBAAA,CACH;;;UACAS,KAAG,CAACR,aAAJ,GAAoB,IAApB;UACA,WAAG,CAACJ,QAAJ,MAAY,IAAZ,IAAYK,aAAZ,GAAY,MAAZ,GAAYA,GAAEU,OAAF,EAAZ;UACAH,KAAG,CAACZ,QAAJ,GAAe,IAAf;QACH,CALD;MAMH,CA3B+B;MA4BhCgB,WAAW;QACP;QACA,OAAOJ,KAAG,CAACV,YAAX;MACH;IA/B+B,CAApC;IAkCAO,MAAM,CAACE,OAAP,GAAiBC,KAAjB;EACH;;EAED,IAAMb,GAAG,GAAGU,MAAM,CAACE,OAAnB;;EAEA,IAAI,CAACZ,GAAG,CAACC,QAAT,EAAmB;IACf;IACAF,cAAc,CAACC,GAAD,CAAd,CAFe,CAGf;IACA;IACA;;IACAH,4BAA4B,CAACqB,QAA7B,CAAsCR,MAAtC,EAA8CV,GAA9C,EAAmDA,GAAnD;EACH;;EAEDN,KAAK,CAACyB,aAAN,CAAoBnB,GAAG,CAACC,QAAxB,EAAmCN,eAAnC;EAEAG,oBAAoB,EAChB;EACAE,GAAG,CAACc,SAFY,EAGhBd,GAAG,CAACiB,WAHY,EAIhBjB,GAAG,CAACiB,WAJY,CAApB,CA3DkF,CAkElF;EACA;EACA;;EACA,IAAIG,YAAJ;EACA,IAAIC,SAAJ;EACArB,GAAG,CAACC,QAAJ,CAAcqB,KAAd,CAAoB;IAChB,IAAI;MACAF,YAAY,GAAGZ,MAAM,EAArB;IACH,CAFD,CAEE,OAAOe,CAAP,EAAU;MACRF,SAAS,GAAGE,CAAZ;IACH;EACJ,CAND;;EAQA,IAAIF,SAAJ,EAAe;IACX,MAAMA,SAAN,CADW,CACK;EACnB;;EAED,OAAOD,YAAP;AACH","names":["Reaction","React","printDebugValue","isUsingStaticRendering","observerFinalizationRegistry","useSyncExternalStore","createReaction","adm","reaction","name","stateVersion","Symbol","onStoreChange","_a","useObserver","render","baseComponentName","admRef","useRef","current","adm_1","subscribe","unregister","dispose","getSnapshot","register","useDebugValue","renderResult","exception","track","e"],"sources":["C:\\Users\\Mohamed\\Desktop\\courses_school\\pro_english\\client\\node_modules\\mobx-react-lite\\src\\useObserver.ts"],"sourcesContent":["import { Reaction } from \"mobx\"\nimport React from \"react\"\nimport { printDebugValue } from \"./utils/printDebugValue\"\nimport { isUsingStaticRendering } from \"./staticRendering\"\nimport { observerFinalizationRegistry } from \"./utils/observerFinalizationRegistry\"\nimport { useSyncExternalStore } from \"use-sync-external-store/shim\"\n\n// Do not store `admRef` (even as part of a closure!) on this object,\n// otherwise it will prevent GC and therefore reaction disposal via FinalizationRegistry.\ntype ObserverAdministration = {\n    reaction: Reaction | null // also serves as disposed flag\n    onStoreChange: Function | null // also serves as mounted flag\n    // stateVersion that 'ticks' for every time the reaction fires\n    // tearing is still present,\n    // because there is no cross component synchronization,\n    // but we can use `useSyncExternalStore` API.\n    // TODO: optimize to use number?\n    stateVersion: any\n    name: string\n    // These don't depend on state/props, therefore we can keep them here instead of `useCallback`\n    subscribe: Parameters<typeof React.useSyncExternalStore>[0]\n    getSnapshot: Parameters<typeof React.useSyncExternalStore>[1]\n}\n\nfunction createReaction(adm: ObserverAdministration) {\n    adm.reaction = new Reaction(`observer${adm.name}`, () => {\n        adm.stateVersion = Symbol()\n        // onStoreChange won't be available until the component \"mounts\".\n        // If state changes in between initial render and mount,\n        // `useSyncExternalStore` should handle that by checking the state version and issuing update.\n        adm.onStoreChange?.()\n    })\n}\n\nexport function useObserver<T>(render: () => T, baseComponentName: string = \"observed\"): T {\n    if (isUsingStaticRendering()) {\n        return render()\n    }\n\n    const admRef = React.useRef<ObserverAdministration | null>(null)\n\n    if (!admRef.current) {\n        // First render\n        const adm: ObserverAdministration = {\n            reaction: null,\n            onStoreChange: null,\n            stateVersion: Symbol(),\n            name: baseComponentName,\n            subscribe(onStoreChange: () => void) {\n                // Do NOT access admRef here!\n                observerFinalizationRegistry.unregister(adm)\n                adm.onStoreChange = onStoreChange\n                if (!adm.reaction) {\n                    // We've lost our reaction and therefore all subscriptions, occurs when:\n                    // 1. Timer based finalization registry disposed reaction before component mounted.\n                    // 2. React \"re-mounts\" same component without calling render in between (typically <StrictMode>).\n                    // We have to recreate reaction and schedule re-render to recreate subscriptions,\n                    // even if state did not change.\n                    createReaction(adm)\n                    // `onStoreChange` won't force update if subsequent `getSnapshot` returns same value.\n                    // So we make sure that is not the case\n                    adm.stateVersion = Symbol()\n                }\n\n                return () => {\n                    // Do NOT access admRef here!\n                    adm.onStoreChange = null\n                    adm.reaction?.dispose()\n                    adm.reaction = null\n                }\n            },\n            getSnapshot() {\n                // Do NOT access admRef here!\n                return adm.stateVersion\n            }\n        }\n\n        admRef.current = adm\n    }\n\n    const adm = admRef.current!\n\n    if (!adm.reaction) {\n        // First render or reaction was disposed by registry before subscribe\n        createReaction(adm)\n        // StrictMode/ConcurrentMode/Suspense may mean that our component is\n        // rendered and abandoned multiple times, so we need to track leaked\n        // Reactions.\n        observerFinalizationRegistry.register(admRef, adm, adm)\n    }\n\n    React.useDebugValue(adm.reaction!, printDebugValue)\n\n    useSyncExternalStore(\n        // Both of these must be stable, otherwise it would keep resubscribing every render.\n        adm.subscribe,\n        adm.getSnapshot,\n        adm.getSnapshot\n    )\n\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    let renderResult!: T\n    let exception\n    adm.reaction!.track(() => {\n        try {\n            renderResult = render()\n        } catch (e) {\n            exception = e\n        }\n    })\n\n    if (exception) {\n        throw exception // re-throw any exceptions caught during rendering\n    }\n\n    return renderResult\n}\n"]},"metadata":{},"sourceType":"module"}